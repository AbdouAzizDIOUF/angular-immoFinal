{"ast":null,"code":"'use strict';\n\nvar datasetKey = 'aaDataset';\nvar valueKey = 'aaValue';\nvar datumKey = 'aaDatum';\n\nvar _ = require('../common/utils.js');\n\nvar DOM = require('../common/dom.js');\n\nvar html = require('./html.js');\n\nvar css = require('./css.js');\n\nvar EventEmitter = require('./event_emitter.js'); // constructor\n// -----------\n\n\nfunction Dataset(o) {\n  o = o || {};\n  o.templates = o.templates || {};\n\n  if (!o.source) {\n    _.error('missing source');\n  }\n\n  if (o.name && !isValidName(o.name)) {\n    _.error('invalid dataset name: ' + o.name);\n  } // tracks the last query the dataset was updated for\n\n\n  this.query = null;\n  this._isEmpty = true;\n  this.highlight = !!o.highlight;\n  this.name = typeof o.name === 'undefined' || o.name === null ? _.getUniqueId() : o.name;\n  this.source = o.source;\n  this.displayFn = getDisplayFn(o.display || o.displayKey);\n  this.debounce = o.debounce;\n  this.cache = o.cache !== false;\n  this.templates = getTemplates(o.templates, this.displayFn);\n  this.css = _.mixin({}, css, o.appendTo ? css.appendTo : {});\n  this.cssClasses = o.cssClasses = _.mixin({}, css.defaultClasses, o.cssClasses || {});\n  this.cssClasses.prefix = o.cssClasses.formattedPrefix || _.formatPrefix(this.cssClasses.prefix, this.cssClasses.noPrefix);\n\n  var clazz = _.className(this.cssClasses.prefix, this.cssClasses.dataset);\n\n  this.$el = o.$menu && o.$menu.find(clazz + '-' + this.name).length > 0 ? DOM.element(o.$menu.find(clazz + '-' + this.name)[0]) : DOM.element(html.dataset.replace('%CLASS%', this.name).replace('%PREFIX%', this.cssClasses.prefix).replace('%DATASET%', this.cssClasses.dataset));\n  this.$menu = o.$menu;\n  this.clearCachedSuggestions();\n} // static methods\n// --------------\n\n\nDataset.extractDatasetName = function extractDatasetName(el) {\n  return DOM.element(el).data(datasetKey);\n};\n\nDataset.extractValue = function extractValue(el) {\n  return DOM.element(el).data(valueKey);\n};\n\nDataset.extractDatum = function extractDatum(el) {\n  var datum = DOM.element(el).data(datumKey);\n\n  if (typeof datum === 'string') {\n    // Zepto has an automatic deserialization of the\n    // JSON encoded data attribute\n    datum = JSON.parse(datum);\n  }\n\n  return datum;\n}; // instance methods\n// ----------------\n\n\n_.mixin(Dataset.prototype, EventEmitter, {\n  // ### private\n  _render: function render(query, suggestions) {\n    if (!this.$el) {\n      return;\n    }\n\n    var that = this;\n    var hasSuggestions;\n    var renderArgs = [].slice.call(arguments, 2);\n    this.$el.empty();\n    hasSuggestions = suggestions && suggestions.length;\n    this._isEmpty = !hasSuggestions;\n\n    if (!hasSuggestions && this.templates.empty) {\n      this.$el.html(getEmptyHtml.apply(this, renderArgs)).prepend(that.templates.header ? getHeaderHtml.apply(this, renderArgs) : null).append(that.templates.footer ? getFooterHtml.apply(this, renderArgs) : null);\n    } else if (hasSuggestions) {\n      this.$el.html(getSuggestionsHtml.apply(this, renderArgs)).prepend(that.templates.header ? getHeaderHtml.apply(this, renderArgs) : null).append(that.templates.footer ? getFooterHtml.apply(this, renderArgs) : null);\n    } else if (suggestions && !Array.isArray(suggestions)) {\n      throw new TypeError('suggestions must be an array');\n    }\n\n    if (this.$menu) {\n      this.$menu.addClass(this.cssClasses.prefix + (hasSuggestions ? 'with' : 'without') + '-' + this.name).removeClass(this.cssClasses.prefix + (hasSuggestions ? 'without' : 'with') + '-' + this.name);\n    }\n\n    this.trigger('rendered', query);\n\n    function getEmptyHtml() {\n      var args = [].slice.call(arguments, 0);\n      args = [{\n        query: query,\n        isEmpty: true\n      }].concat(args);\n      return that.templates.empty.apply(this, args);\n    }\n\n    function getSuggestionsHtml() {\n      var args = [].slice.call(arguments, 0);\n      var $suggestions;\n      var nodes;\n      var self = this;\n      var suggestionsHtml = html.suggestions.replace('%PREFIX%', this.cssClasses.prefix).replace('%SUGGESTIONS%', this.cssClasses.suggestions);\n      $suggestions = DOM.element(suggestionsHtml).css(this.css.suggestions); // jQuery#append doesn't support arrays as the first argument\n      // until version 1.8, see http://bugs.jquery.com/ticket/11231\n\n      nodes = _.map(suggestions, getSuggestionNode);\n      $suggestions.append.apply($suggestions, nodes);\n      return $suggestions;\n\n      function getSuggestionNode(suggestion) {\n        var $el;\n        var suggestionHtml = html.suggestion.replace('%PREFIX%', self.cssClasses.prefix).replace('%SUGGESTION%', self.cssClasses.suggestion);\n        $el = DOM.element(suggestionHtml).attr({\n          role: 'option',\n          id: ['option', Math.floor(Math.random() * 100000000)].join('-')\n        }).append(that.templates.suggestion.apply(this, [suggestion].concat(args)));\n        $el.data(datasetKey, that.name);\n        $el.data(valueKey, that.displayFn(suggestion) || undefined); // this led to undefined return value\n\n        $el.data(datumKey, JSON.stringify(suggestion));\n        $el.children().each(function () {\n          DOM.element(this).css(self.css.suggestionChild);\n        });\n        return $el;\n      }\n    }\n\n    function getHeaderHtml() {\n      var args = [].slice.call(arguments, 0);\n      args = [{\n        query: query,\n        isEmpty: !hasSuggestions\n      }].concat(args);\n      return that.templates.header.apply(this, args);\n    }\n\n    function getFooterHtml() {\n      var args = [].slice.call(arguments, 0);\n      args = [{\n        query: query,\n        isEmpty: !hasSuggestions\n      }].concat(args);\n      return that.templates.footer.apply(this, args);\n    }\n  },\n  // ### public\n  getRoot: function getRoot() {\n    return this.$el;\n  },\n  update: function update(query) {\n    function handleSuggestions(suggestions) {\n      // if the update has been canceled or if the query has changed\n      // do not render the suggestions as they've become outdated\n      if (!this.canceled && query === this.query) {\n        // concat all the other arguments that could have been passed\n        // to the render function, and forward them to _render\n        var extraArgs = [].slice.call(arguments, 1);\n        this.cacheSuggestions(query, suggestions, extraArgs);\n\n        this._render.apply(this, [query, suggestions].concat(extraArgs));\n      }\n    }\n\n    this.query = query;\n    this.canceled = false;\n\n    if (this.shouldFetchFromCache(query)) {\n      handleSuggestions.apply(this, [this.cachedSuggestions].concat(this.cachedRenderExtraArgs));\n    } else {\n      var that = this;\n\n      var execSource = function execSource() {\n        // When the call is debounced the condition avoid to do a useless\n        // request with the last character when the input has been cleared\n        if (!that.canceled) {\n          that.source(query, handleSuggestions.bind(that));\n        }\n      };\n\n      if (this.debounce) {\n        var later = function later() {\n          that.debounceTimeout = null;\n          execSource();\n        };\n\n        clearTimeout(this.debounceTimeout);\n        this.debounceTimeout = setTimeout(later, this.debounce);\n      } else {\n        execSource();\n      }\n    }\n  },\n  cacheSuggestions: function cacheSuggestions(query, suggestions, extraArgs) {\n    this.cachedQuery = query;\n    this.cachedSuggestions = suggestions;\n    this.cachedRenderExtraArgs = extraArgs;\n  },\n  shouldFetchFromCache: function shouldFetchFromCache(query) {\n    return this.cache && this.cachedQuery === query && this.cachedSuggestions && this.cachedSuggestions.length;\n  },\n  clearCachedSuggestions: function clearCachedSuggestions() {\n    delete this.cachedQuery;\n    delete this.cachedSuggestions;\n    delete this.cachedRenderExtraArgs;\n  },\n  cancel: function cancel() {\n    this.canceled = true;\n  },\n  clear: function clear() {\n    this.cancel();\n    this.$el.empty();\n    this.trigger('rendered', '');\n  },\n  isEmpty: function isEmpty() {\n    return this._isEmpty;\n  },\n  destroy: function destroy() {\n    this.clearCachedSuggestions();\n    this.$el = null;\n  }\n}); // helper functions\n// ----------------\n\n\nfunction getDisplayFn(display) {\n  display = display || 'value';\n  return _.isFunction(display) ? display : displayFn;\n\n  function displayFn(obj) {\n    return obj[display];\n  }\n}\n\nfunction getTemplates(templates, displayFn) {\n  return {\n    empty: templates.empty && _.templatify(templates.empty),\n    header: templates.header && _.templatify(templates.header),\n    footer: templates.footer && _.templatify(templates.footer),\n    suggestion: templates.suggestion || suggestionTemplate\n  };\n\n  function suggestionTemplate(context) {\n    return '<p>' + displayFn(context) + '</p>';\n  }\n}\n\nfunction isValidName(str) {\n  // dashes, underscores, letters, and numbers\n  return /^[_a-zA-Z0-9-]+$/.test(str);\n}\n\nmodule.exports = Dataset;","map":null,"metadata":{},"sourceType":"script"}