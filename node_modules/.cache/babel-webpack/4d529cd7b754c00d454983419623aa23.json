{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport urlHelper from 'algoliasearch-helper/src/url';\nimport isEqual from 'lodash/isEqual';\nvar AlgoliaSearchHelper = algoliasearchHelper.AlgoliaSearchHelper;\n/**\n * @typedef {object} UrlUtil\n * @property {string} character the character used in the url\n * @property {function} onpopstate add an event listener for the URL change\n * @property {function} pushState creates a new entry in the browser history\n * @property {function} readUrl reads the query string of the parameters\n */\n\n/**\n * Handles the legacy browsers\n * @type {UrlUtil}\n */\n\nvar hashUrlUtils = {\n  ignoreNextPopState: false,\n  character: '#',\n  onpopstate: function onpopstate(cb) {\n    var _this = this;\n\n    this._onHashChange = function (hash) {\n      if (_this.ignoreNextPopState) {\n        _this.ignoreNextPopState = false;\n        return;\n      }\n\n      cb(hash);\n    };\n\n    window.addEventListener('hashchange', this._onHashChange);\n  },\n  pushState: function pushState(qs) {\n    // hash change or location assign does trigger an hashchange event\n    // so every time we change it manually, we inform the code\n    // to ignore the next hashchange event\n    // see https://github.com/algolia/instantsearch.js/issues/2012\n    this.ignoreNextPopState = true;\n    window.location.assign(getFullURL(this.createURL(qs)));\n  },\n  createURL: function createURL(qs) {\n    return window.location.search + this.character + qs;\n  },\n  readUrl: function readUrl() {\n    return window.location.hash.slice(1);\n  },\n  dispose: function dispose() {\n    window.removeEventListener('hashchange', this._onHashChange);\n    window.location.assign(getFullURL(''));\n  }\n};\n/**\n * Handles the modern API\n * @type {UrlUtil}\n */\n\nvar modernUrlUtils = {\n  character: '?',\n  onpopstate: function onpopstate(cb) {\n    this._onPopState = function () {\n      return cb.apply(undefined, arguments);\n    };\n\n    window.addEventListener('popstate', this._onPopState);\n  },\n  pushState: function pushState(qs, _ref) {\n    var getHistoryState = _ref.getHistoryState;\n    window.history.pushState(getHistoryState(), '', getFullURL(this.createURL(qs)));\n  },\n  createURL: function createURL(qs) {\n    return this.character + qs + document.location.hash;\n  },\n  readUrl: function readUrl() {\n    return window.location.search.slice(1);\n  },\n  dispose: function dispose() {\n    window.removeEventListener('popstate', this._onPopState);\n    window.history.pushState(null, null, getFullURL(''));\n  }\n}; // we always push the full url to the url bar. Not a relative one.\n// So that we handle cases like using a <base href>, see\n// https://github.com/algolia/instantsearch.js/issues/790 for the original issue\n\nfunction getFullURL(relative) {\n  return getLocationOrigin() + window.location.pathname + relative;\n} // IE <= 11 has no location.origin or buggy\n\n\nfunction getLocationOrigin() {\n  // eslint-disable-next-line max-len\n  return window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n} // see InstantSearch.js file for urlSync options\n\n\nvar URLSync = function () {\n  function URLSync(urlUtils, options) {\n    _classCallCheck(this, URLSync);\n\n    this.urlUtils = urlUtils;\n    this.originalConfig = null;\n    this.mapping = options.mapping || {};\n\n    this.getHistoryState = options.getHistoryState || function () {\n      return null;\n    };\n\n    this.threshold = options.threshold || 700;\n    this.trackedParameters = options.trackedParameters || ['query', 'attribute:*', 'index', 'page', 'hitsPerPage'];\n    this.firstRender = true;\n    this.searchParametersFromUrl = AlgoliaSearchHelper.getConfigurationFromQueryString(this.urlUtils.readUrl(), {\n      mapping: this.mapping\n    });\n  }\n\n  _createClass(URLSync, [{\n    key: 'init',\n    value: function init(_ref2) {\n      var state = _ref2.state;\n      this.initState = state;\n    }\n  }, {\n    key: 'getConfiguration',\n    value: function getConfiguration(currentConfiguration) {\n      // we need to create a REAL helper to then get its state. Because some parameters\n      // like hierarchicalFacet.rootPath are then triggering a default refinement that would\n      // be not present if it was not going trough the SearchParameters constructor\n      this.originalConfig = algoliasearchHelper({}, currentConfiguration.index, currentConfiguration).state;\n      return this.searchParametersFromUrl;\n    }\n  }, {\n    key: 'render',\n    value: function render(_ref3) {\n      var _this2 = this;\n\n      var helper = _ref3.helper,\n          state = _ref3.state;\n\n      if (this.firstRender) {\n        this.firstRender = false;\n        this.onHistoryChange(this.onPopState.bind(this, helper));\n        helper.on('change', function (s) {\n          return _this2.renderURLFromState(s);\n        });\n        var initStateQs = this.getQueryString(this.initState);\n        var stateQs = this.getQueryString(state);\n\n        if (initStateQs !== stateQs) {\n          // force update the URL, if the state has changed since the initial URL read\n          // We do this in order to make a URL update when there is search function\n          // that prevent the search of the initial rendering\n          // See: https://github.com/algolia/instantsearch.js/issues/2523#issuecomment-339356157\n          this.renderURLFromState(state);\n        }\n      }\n    }\n  }, {\n    key: 'dispose',\n    value: function dispose(_ref4) {\n      var helper = _ref4.helper;\n      helper.removeListener('change', this.renderURLFromState);\n      this.urlUtils.dispose();\n    }\n  }, {\n    key: 'onPopState',\n    value: function onPopState(helper, fullState) {\n      clearTimeout(this.urlUpdateTimeout); // compare with helper.state\n\n      var partialHelperState = helper.getState(this.trackedParameters);\n\n      var fullHelperState = _extends({}, this.originalConfig, partialHelperState);\n\n      if (isEqual(fullHelperState, fullState)) return;\n      helper.overrideStateWithoutTriggeringChangeEvent(fullState).search();\n    }\n  }, {\n    key: 'renderURLFromState',\n    value: function renderURLFromState(state) {\n      var _this3 = this;\n\n      var qs = this.getQueryString(state);\n      clearTimeout(this.urlUpdateTimeout);\n      this.urlUpdateTimeout = setTimeout(function () {\n        _this3.urlUtils.pushState(qs, {\n          getHistoryState: _this3.getHistoryState\n        });\n      }, this.threshold);\n    }\n  }, {\n    key: 'getQueryString',\n    value: function getQueryString(state) {\n      var currentQueryString = this.urlUtils.readUrl();\n      var foreignConfig = AlgoliaSearchHelper.getForeignConfigurationInQueryString(currentQueryString, {\n        mapping: this.mapping\n      });\n      return urlHelper.getQueryStringFromState(state.filter(this.trackedParameters), {\n        moreAttributes: foreignConfig,\n        mapping: this.mapping,\n        safe: true\n      });\n    } // External APIs\n\n  }, {\n    key: 'createURL',\n    value: function createURL(state, _ref5) {\n      var absolute = _ref5.absolute;\n      var filteredState = state.filter(this.trackedParameters);\n      var relative = this.urlUtils.createURL(algoliasearchHelper.url.getQueryStringFromState(filteredState, {\n        mapping: this.mapping\n      }));\n      return absolute ? getFullURL(relative) : relative;\n    }\n  }, {\n    key: 'onHistoryChange',\n    value: function onHistoryChange(fn) {\n      var _this4 = this;\n\n      this.urlUtils.onpopstate(function () {\n        var qs = _this4.urlUtils.readUrl();\n\n        var partialState = AlgoliaSearchHelper.getConfigurationFromQueryString(qs, {\n          mapping: _this4.mapping\n        });\n\n        var fullState = _extends({}, _this4.originalConfig, partialState);\n\n        fn(fullState);\n      });\n    }\n  }]);\n\n  return URLSync;\n}();\n/**\n * Instantiate a url sync widget. This widget let you synchronize the search\n * parameters with the URL. It can operate with legacy API and hash or it can use\n * the modern history API. By default, it will use the modern API, but if you are\n * looking for compatibility with IE8 and IE9, then you should set 'useHash' to\n * true.\n * @param {object} options all the parameters to configure the URL synchronization. It\n * may contain the following keys :\n *  - threshold:number time in ms after which a new state is created in the browser\n * history. The default value is 700.\n *  - trackedParameters:string[] parameters that will be synchronized in the\n * URL. By default, it will track the query, all the refinable attributes (facets and numeric\n * filters), the index and the page.\n *  - useHash:boolean if set to true, the url will be hash based. Otherwise,\n * it'll use the query parameters using the modern history API.\n * @return {object} the widget instance\n */\n\n\nfunction urlSync() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useHash = options.useHash || false;\n  var customUrlUtils = options.urlUtils;\n  var urlUtils = customUrlUtils || (useHash ? hashUrlUtils : modernUrlUtils);\n  return new URLSync(urlUtils, options);\n}\n\nexport default urlSync;","map":null,"metadata":{},"sourceType":"module"}